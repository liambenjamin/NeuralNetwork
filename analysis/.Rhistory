grp.1
grp.2 = abs(cp - med_c)
med_c =  quantile(cp, 0.5) # alternatively > summary(cp)[3]
grp.2 = abs(cp - med_c)
grp.1
# Step 4: Perform an equal variance independent 2 sample t-test w/ grp.1 and grp.2
t.test(grp.1, grp.2, var.equal=TRUE)
install.packages("car")
require(car)
library(car)
?leveneTest
# y : the concatenation of sample 1 and sample 2 values
y = c(pp, cp)
y
rep(1, 3)
rep("hello", 2)
length(pp)
length(cp)
rep("P", length(pp))
rep("C", length(cp))
group = c(rep("P", length(pp)), rep("C", length(cp)))
group
View(data.frame(y=y, group=group))
# levene's test in R
# input: (y vector, group vector, center=median)
leveneTest(y, group, center=median)
# levene's test in R
# input: (y vector, group vector, center=median)
leveneTest(y, group, center=median)
# group : specifies which sample the values of `y` belong to
group = as.factor(c(rep("P", length(pp)), rep("C", length(cp))))
# levene's test in R
# input: (y vector, group vector, center=median)
leveneTest(y, group, center=median)
t.test(pp,cp,var.equal=FALSE, conf.level=0.95)
rnorm(1)
rnorm(2)
rnorm(10)
qqnorm(rnorm(10))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
qqnorm(rnorm(1000))
qqnorm(rnorm(1000))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
# enter data
pp = c(6.5, 5.5, 5.0, 7.0, 7.9, 9.1, 5.2)
cp = c(7.5, 6.5, 8.0, 9.0, 8.5, 9.9, 7.2, 7.5)
summary(pp)
summary(pp)[3]
# Step 1: Determine the median of each sample
med.p = quantile(pp, 0.5)
med.p
med.c = quantile(cp, 0.5)
med.p
med.c
pp - med.p
abs(pp - med.p)
# Step 2:Subtract the corresponding median from each observation
# Step 3: Calculate the absolute values of the results
grp.1 = abs(pp - med.p)
grp.2 = abs(cp - med.c)
grp.1
grp.2
# Step 4: Perform an independent samples, equal-variance T-test
t.test(grp.1, grp.2, var.equal=TRUE)
# repeat test using leveneTest( ) in the `car` package
library(car)
# y : concentation of sample 1 and sample 2 (ie pp and cp)
y = c(pp, cp)
y
n1 = length(pp)
n2 = length(cp)
n1
n2
rep(1, 4)
rep("Liam", 3)
# group : indicate which group each value in `y` belongs to
group = as.factor(c(rep("P", n1), rep("C", n2)))
View(data.frame(y=y,group=group))
# leveneTest(concatenated data vector, group indictor vector, center=median)
leveneTest(y, group, center=median)
t.test(pp, cp, var.equal=FALSE)
t.test(pp, cp, var.equal=FALSE, conf.level = 0.95)
par(mfrow=c(1,2))
# normal quantile plot of group 1 (pp)
qqnorm(pp)
# normal quantile plot of group 1 (pp)
qqnorm(cp)
# normal quantile plot of group 1 (pp)
qqnorm(pp)
# normal quantile plot of group 1 (pp)
qqnorm(cp)
par(mfrow=c(2,1))
# normal quantile plot of group 1 (pp)
qqnorm(pp)
# normal quantile plot of group 1 (pp)
qqnorm(cp)
par(mfrow=c(1,1))
# normal quantile plot of group 1 (pp)
qqnorm(pp)
# normal quantile plot of group 1 (pp)
qqnorm(cp)
?par
?mfrow
# enter data
potato = c(6.5, 5.5, 5.0, 7.0, 7.9, 9.1, 5.2)
corn = c(7.5, 6.5, 8.0, 9.0, 8.5, 9.9, 7.2, 7.5)
potato
corn
# Step 1: Determine the median of each sample
p_med = quantile(potato, 0.5)
c_med = quantile(corn, 0.5)
p_med
c_med
median(potato)
# Step 1: Determine the median of each sample
p_med = median(potato)
c_med = median(corn)
p_med
c_med
# Step 2:Subtract the corresponding median from each observation
# Step 3: Calculate the absolute values of the results
p_new = abs(potato - p_med)
c_new = abs(corn - c_med)
p_new
c_new
# if you haven't installed the pkg `car`
# install.packages("car")
require(car)
y = c(potato, corn)
t
y
n1 = length(potato)
n1
rep(3, 2)
rep("Liam", 5)
y
n1
n2
n2 = length(corn) # sample size for group 2
n1
n2
rep("P", n1)
group = c(rep("P", n1), rep("C", n2))
group
View(data.frame(y=y,group=group))
t.test(potato, corn, var.equal=FALSE)
rnorm(1)
rnorm(4)
qqnorm(rnorm(10000))
qqnorm(rnorm(10000))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
qqnorm(rnorm(10))
x = c(32, 36, 32, 41, 36, 32, 37)
y = c(121,114,79,151)
x
y
t.test(x,y, var.equal=TRUE)
t.test(x,y)
t.test(x,y,var.equal = T)
# Enter data
low = c(32,36,32,41,36,32,37)
high = c(121,114,79,151)
# Step 1
m_low = median(low)
m_high = median(high)
m_low
low
m_high
high
low_minus_m_low = low - m_low
high_minus_m_high = high - m_high
low_minus_m_low
high_minus_m_high
# Step 2
abs_low = abs(low_minus_m_low)
abs_high = abs(high_minus_m_high)
abs_low
abs_high
# Step 3
t.test(abs_low, abs_high)
# Step 3
t.test(abs_low, abs_high, var.equal=T)
require(car)
?leveneTest
y = c(low, high)
low
high
y
# Step 2: Generate the group vector that indicates which elements of y belong to which sample
n1 = length(low)
n1
n2 = length(high)
n2
rep(5, 3)
rep(5, 7)
rep("Liam", 2)
rep("L", n1)
rep("H", n2)
group = c(rep("L", n1), rep("H", n2))
group
View(data.frame(y=y, group=group))
# run leveneTest( )
leveneTest(y=y, group=group, center=median)
group = as.factor(c(rep("L", n1), rep("H", n2)))
# run leveneTest( )
leveneTest(y=y, group=group, center=median)
pr1 = c(7, 11, 13, 9, 9, 23, 12, 6, 12, 14)
pr2 = c(22, 9,12, 12, 31, 22, 14, 16, 17, 13)
length(pr1)
length(pr2)
pr1 = log(c(7, 11, 13, 9, 9, 23, 12, 6, 12, 14))
pr2 = log(c(22, 9,12, 12, 31, 22, 14, 16, 17, 13))
pr1
pr2
qqnorm(pr1)
par(mfrow=c(1,2))
qqnorm(pr1)
qqnorm(pr2)
qqnorm(pr1, main="Normal Q-Q Plot\nPrairie 1 log transform")
qqnorm(pr2, main="Normal Q-Q Plot\nPrairie 2 log transform")
pr1 = log(c(7, 11, 13, 9, 9, 23, 12, 6, 12, 14))
pr2 = log(c(22, 9,12, 12, 31, 22, 14, 16, 17, 13))
var(pr1)
var(pr2)
# Independent two sample test (equal variance)
t.test(pr1, pr2, var.equal=TRUE)
t.test(pr1, pr2, var.equal=TRUE, paried=TRUE)
t.test(pr1, pr2, var.equal=TRUE, paired=TRUE)
y = c(8,12,10,3,5,18,13,11,18)
x = c(15,17,25,19,28,17,12,20,16)
length(x)
length(y)
# Wilcoxon Signed Rank Test (Paired)
ordered = c(15,17,25,19,28,17,12,20,16)
customers = c(8,12,10,3,5,18,13,11,18)
wilcox.test(ordered, customers, paired = TRUE, alternative = "two.sided")
# Wilcoxon Signed Rank Test (Paired)
ordered = c(15,17,25,19,28,14,12,20,16)
customers = c(8,12,10,3,5,18,13,11,18)
wilcox.test(ordered, customers, paired = TRUE, alternative = "two.sided")
# Wilcoxon Signed Rank Test (Paired)
ordered = c(15,17,25,19,28,17,12,20,16)
customers = c(8,12,10,3,5,18,13,11,18)
wilcox.test(ordered, customers, paired = TRUE, alternative = "two.sided")
pr1 = c(7, 11,13, 9, 9, 23,12, 6, 12, 14)
pr2 = c(22, 9, 12,12,31,22,14,16,17,13)
pr1
pr2
length(pr1) == length(pr2)
# histograms
par(mfrow = c(1,2))
hist(pr1, main="Histogram Prairie 1")
hist(pr2, main="Histogram Prairie 2")
qqnorm(pr1, main="Prairie 1")
qqnorm(pr2, main="Prairie 2")
# sqrt transformation
qqnorm(sqrt(pr1), main="Prairie 1 Sqrt")
qqnorm(sqrt(pr2), main="Prairie 2 Sqrt")
# log transformation
qqnorm(log(pr1), main="Prairie 1 log")
qqnorm(log(pr2), main="Prairie 2 log")
qqnorm(pr1, main="Prairie 1")
qqnorm(pr2, main="Prairie 2")
# side-by-side
par(mfrow=c(2,3))
qqnorm(pr1, main="Prairie 1")
qqnorm(pr2, main="Prairie 2")
qqnorm(pr2, main="Prairie 2")
qqnorm(pr1, main="Prairie 1")
qqnorm(pr2, main="Prairie 2")
qqnorm(pr2, main="Prairie 2")
qqnorm(pr1, main="Prairie 1")
qqnorm(sqrt(pr1), main="Prairie 1 Sqrt")
qqnorm(log(pr1), main="Prairie 1 log")
qqnorm(pr2, main="Prairie 2")
qqnorm(sqrt(pr2), main="Prairie 2 Sqrt")
qqnorm(log(pr2), main="Prairie 2 log")
sd(log(pr1))
sd(log(pr2))
log.pr1 = log(pr1)
log.pr2 = log(pr2)
?t.test
pr1
pr2
D = pr1 - pr2
D
# evaluate the normality assumption using a qq-plot
par(mfrow=c(1,1))
qqnorm(D)
# evaluate the normality assumption using a qq-plot
par(mfrow=c(1,2))
qqnorm(D, main="Untransformed")
qqnorm(log(D), main="Transformed")
log(-1)
ls
D
D = D + min(D)
qqnorm(D, main="Untransformed")
qqnorm(log(D), main="Transformed")
D = D + min(D) +1
# evaluate the normality assumption using a qq-plot
par(mfrow=c(1,2))
qqnorm(D, main="Untransformed")
qqnorm(log(D), main="Transformed")
D
D = (pr1 - pr2)
D = D - min(D)
D
D = (pr1 - pr2)
D
min(D)
D = D + abs(min(D))
t.test(log.pr1, log.pr2, var.equal=TRUE, paired=TRUE)
pr1 = c(7, 11,13, 9, 9, 23,12, 6, 12,14)
pr2 = c(22, 9,12,12,31,22,14,16,17,13)
length(pr1) = length(pr2)
pr1 = c(7, 11,13, 9, 9, 23,12, 6, 12,14)
pr2 = c(22, 9,12,12,31,22,14,16,17,13)
length(pr1) == length(pr2)
# histograms
hist(pr1)
hist(pr2)
# normal quantile plots
qqnorm(pr1)
qqnorm(pr2)
# normal quantile plots
par(mfrow=c(2,3))
qqnorm(pr1, main="Prairie 1")
qqnorm(sqrt(pr1), main="Sqrt(Prairie 1)")
qqnorm(log(pr1), main="Log(Prairie 1)")
qqnorm(pr2, main="Prairie 2")
qqnorm(sqrt(pr2), main="Sqrt(Prairie 2)")
qqnorm(log(pr2), main="Log(Prairie 2)")
log.pr1 = log(pr1)
log.pr2 = log(pr2)
sd(log.pr1)
sd(log.pr2)
# 2 sample independent, equal variance t-test on the transformed data
t.test(log.pr1, log.pr2, var.equal = TRUE)
t.test(log.pr1, log.pr2, var.equal = TRUE, paired = TRUE)
pr1 = c(7, 11,13, 9, 9, 23,12, 6, 12,14)
pr2 = c(22, 9 ,12,12,31,22,14,16,17,13)
length(pr1) == length(pr2)
# histograms
hist(pr1)
hist(pr2)
log10(5)
log(5)
# normal quantile plots
par(mfrow=c(2,3))
qqnorm(pr1, main="Prairie 1")
qqnorm(sqrt(pr1), main="Sqrt(Prairie 1)")
qqnorm(log(pr1), main="Log(Prairie 1)")
qqnorm(pr2, main="Prairie 2")
qqnorm(sqrt(pr2), main="Sqrt(Prairie 2)")
qqnorm(log(pr2), main="Log(Prairie 2)")
log.pr1 = log(pr1)
log.pr2 = log(pr2)
sd(log.pr1)
sd(log.pr2)
# 2 sample indep. t-test w/ equal vairances
t.test(log.pr1, log.pr2, var.equal=TRUE)
t.test(log.pr1, log.pr2, var.equal = TRUE, paired=TRUE)
?t.test
t.test(log.pr1, log.pr2, var.equal=TRUE)
t.test(log.pr1, log.pr2, var.equal=TRUE, alternative="two.sided")
t.test(log.pr1, log.pr2, var.equal=TRUE, alternative="less")
t.test(log.pr1, log.pr2, var.equal=TRUE, alternative="greater")
sample(1:6,3)
sample(1:6,3)
sample(1:6,3)
R1=132
n1 = 12
n2 = 12
N = 1:1000
samp_rank = rep(NA, N)
N = 1000
samp_rank = rep(NA, N)
for (i in 1:N) {
samp_rank[i] = sum(sample(1:(n1+n2), n1))
}
p.upper = sum(which(samp_rank >= R1)) / N
p.val = 2 * p.upper
p.val
sum(sample(1:(n1+n2), n1))
p.upper = sum(which(samp_rank <= R1)) / N
p.upper
p.upper = which(samp_rank <= R1) / N
p.upper
p.upper = which(samp_rank <= R1)
p.upper
p.upper = length(which(samp_rank <= R1)) / N
p.upper
p.val = 2 * p.upper
p.val = 2 * p.upper
p.val
?wilcox.test
grp1 = c(80, 79, 92, 65, 83, 84, 95, 78, 81, 85, 73, 52)
grp2 = c(82, 87, 89, 91, 93, 76, 74, 70, 88, 99, 61, 94)
wilcox.test(grp1, grp2)
wilcox.test(grp1, grp2, exact=TRUE)
wilcox.test(grp1, grp2, exact=FALSE)
wilcox.test(grp1, grp2, correct=T)
wilcox.test(grp1, grp2, correct=F)
wilcox.test(grp1, grp2, paired=T)
wilcox.test(grp1, grp2, paired=F)
wilcox.test(grp1, grp2)
rand_stats = rep(NA, N)
data = c(grp1,grp2)
data
length(data)
test_star = abs(mean(grp1) - mean(grp2))
for (i in 1:N) {
rand_stats[i] = abs(mean(samp.1)-mean(samp.2))
}
rand_stats = rep(NA, N)
data = c(grp1,grp2)
test_star = abs(mean(grp1) - mean(grp2))
for (i in 1:N) {
samp.1 = sample(data, n1)
samp.2 = data[-samp.1]
rand_stats[i] = abs(mean(samp.1)-mean(samp.2))
}
ct = length(which(rand_stats >= test_star))
p.val = 2 * ct / N
p.val
rand_stats = rep(NA, N)
data = c(grp1,grp2)
test_star = mean(grp1) - mean(grp2)
for (i in 1:N) {
samp.1 = sample(data, n1)
samp.2 = data[-samp.1]
rand_stats[i] = mean(samp.1)-mean(samp.2)
}
ct.upper = length(which(rand_stats >= test_star))
ct.lower = length(which(rand_stats <= test_star))
hist(rand_stats)
abline(v=test_star, col="red")
p.val = 2 * ct.lower / N
p.val
grp1 = c(80, 79, 92, 65, 83, 84, 95, 78, 81, 85, 73, 52)
grp2 = c(82, 87, 89, 91, 93, 76, 74, 70, 88, 99, 61, 94)
rand_stats = rep(NA, N)
data = c(grp1,grp2)
test_star = abs(mean(grp1) - mean(grp2))
rand_stats[i] = abs(mean(samp.1)-mean(samp.2))
hist(rand_stats)
abline(v=test_star, col="red")
rand_stats
rand_stats = rep(NA, N)
data = c(grp1,grp2)
samp.1 = sample(data, n1)
samp.1
samp.2 = data[-samp.1]
samp.2
data
data[-samp.1]
which(data != samp.1)
which(data not in samp.1)
which(data == samp.1)
which(data in samp.1)
samp.2 = data[!data %in% samp.1]
samp.2
samp.1
rand_stats = rep(NA, N)
data = c(grp1,grp2)
test_star = abs(mean(grp1) - mean(grp2))
for (i in 1:N) {
samp.1 = sample(data, n1)
samp.2 = data[!data %in% samp.1]
rand_stats[i] = abs(mean(samp.1)-mean(samp.2))
}
hist(rand_stats)
abline(v=test_star, col="red")
ct = which(rand_stats >= test_star)
ct = length(which(rand_stats >= test_star))
p.val = ct / N
p.val
qnorm(.95)
F_test = as.matrix(read.csv("mnist/F_test_1e1.csv", header=FALSE))
setwd("~/Desktop/nN/analysis")
F_test = as.matrix(read.csv("mnist/F_test_1e1.csv", header=FALSE))
F_train = as.matrix(read.csv("mnist/F_train_1e1.csv", header=FALSE))
#require(ggplot2)
require(plotly)
p <- plot_ly(z = F_test, type = "surface")
p2 <- plot_ly(z = F_train, type = "surface")
p
p2
fig <- plot_ly(z = ~F_test)
fig <- fig %>% add_surface()
fig
x = seq(0,1,1/20)
y = seq(0,1,1/20)
plot_ly(x = x, y = y, z = F_test, type = "surface")
?plot_ly
